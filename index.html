<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>机器视觉每日资讯</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="styles/base.css?v=v4">
<style>
/* Clustering specific styles */
.cluster-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  padding: 16px;
  background: #f8fafc;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  margin: 16px 0;
}

.cluster-toolbar label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 500;
  font-size: 14px;
}

.threshold-control {
  display: flex;
  align-items: center;
  gap: 8px;
}

.threshold-slider {
  width: 150px;
  height: 4px;
  background: #e5e7eb;
  border-radius: 2px;
  outline: none;
  -webkit-appearance: none;
}

.threshold-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: #0f4c81;
  border-radius: 50%;
  cursor: pointer;
}

.threshold-value {
  font-weight: 600;
  color: #0f4c81;
  min-width: 40px;
}

.cluster-actions {
  display: flex;
  gap: 8px;
  margin-left: auto;
}

.cluster-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 20px;
  margin: 20px 0;
}

.cluster-card {
  background: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: all 0.3s ease;
}

.cluster-card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  transform: translateY(-2px);
}

.cluster-header {
  margin-bottom: 12px;
}

.cluster-title {
  font-size: 18px;
  font-weight: 600;
  color: #0f4c81;
  margin: 0 0 8px 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.llm-badge {
  background: linear-gradient(45deg, #10b981, #059669);
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.cluster-stats {
  display: flex;
  gap: 12px;
  font-size: 12px;
  color: #64748b;
  flex-wrap: wrap;
}

.cluster-summary {
  background: #f0f9ff;
  padding: 8px 10px;
  border-left: 3px solid #0ea5e9;
  border-radius: 4px;
  font-size: 13px;
  line-height: 1.4;
  margin-bottom: 12px;
}

.cluster-items .news-item {
  border-bottom: 1px solid #f1f5f9;
  padding: 8px 0;
}

.cluster-items .news-item:last-child {
  border-bottom: none;
}

.item-title {
  font-size: 14px;
  font-weight: 500;
  margin: 0 0 4px 0;
  line-height: 1.3;
}

.item-meta {
  font-size: 11px;
  color: #64748b;
  margin-bottom: 4px;
}

.item-summary {
  font-size: 12px;
  line-height: 1.4;
  color: #374151;
  margin-bottom: 6px;
}

.item-tags {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-bottom: 6px;
}

.item-tags .tag {
  background: #f1f5f9;
  color: #475569;
  padding: 1px 4px;
  border-radius: 3px;
  font-size: 10px;
}

.item-actions {
  display: flex;
  gap: 8px;
}

.source-link, .card-btn {
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 4px;
  text-decoration: none;
  border: none;
  cursor: pointer;
}

.source-link {
  background: #0f4c81;
  color: white;
}

.card-btn {
  background: #e5e7eb;
  color: #374151;
}

.expand-toggle {
  text-align: center;
  margin: 8px 0;
}

.expand-btn {
  background: none;
  border: 1px solid #e5e7eb;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 11px;
  cursor: pointer;
  color: #64748b;
}

.cluster-card .cluster-items-hidden {
  display: none;
}

.cluster-card.expanded .cluster-items-hidden {
  display: block;
}

.cluster-card.expanded .expand-text {
  display: none;
}

.collapse-text {
  display: none;
}

.cluster-card.expanded .collapse-text {
  display: inline;
}

.cluster-updating {
  opacity: 0.6;
  transition: opacity 0.3s ease;
}

.empty-state {
  text-align: center;
  padding: 40px;
  color: #64748b;
}

.progress-bar {
  width: 100%;
  height: 4px;
  background: #e5e7eb;
  border-radius: 2px;
  overflow: hidden;
  margin: 8px 0;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #10b981, #059669);
  width: 0%;
  transition: width 0.3s ease;
}

.settings-panel {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.settings-content {
  background: white;
  border-radius: 12px;
  padding: 24px;
  max-width: 480px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.settings-header h3 {
  margin: 0;
  color: #0f4c81;
}

.close-btn {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  color: #64748b;
  padding: 0;
  line-height: 1;
}

.form-group {
  margin-bottom: 16px;
}

.form-group label {
  display: block;
  margin-bottom: 4px;
  font-weight: 500;
  font-size: 14px;
}

.form-group input, .form-group select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  font-size: 14px;
}

.settings-actions {
  display: flex;
  gap: 12px;
  margin-top: 20px;
}

.status-message {
  margin-top: 12px;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 13px;
}

.status-message.success {
  background: #dcfce7;
  color: #16a34a;
  border: 1px solid #bbf7d0;
}

.status-message.error {
  background: #fef2f2;
  color: #dc2626;
  border: 1px solid #fecaca;
}

.status-message.info {
  background: #eff6ff;
  color: #2563eb;
  border: 1px solid #dbeafe;
}

@media (max-width: 768px) {
  .cluster-toolbar {
    flex-direction: column;
    align-items: stretch;
  }
  
  .cluster-actions {
    margin-left: 0;
    justify-content: center;
  }
  
  .cluster-grid {
    grid-template-columns: 1fr;
  }
}
</style>
</head>
<body>
<header class="site-header">
  <div class="logo-wrap">
    <img id="siteLogo" alt="logo" />
    <h1>机器视觉每日资讯</h1>
  </div>
  <div class="header-actions">
    <button id="langToggleBtn" class="ghost-btn">中/EN</button>
    <a href="legacy-index.html" class="secondary small">Legacy View</a>
    <a href="card-generator.html" class="primary small">学习卡片生成</a>
  </div>
</header>

<section class="cluster-toolbar">
  <div class="threshold-control">
    <label for="thresholdSlider">Clustering Threshold:</label>
    <input 
      type="range" 
      id="thresholdSlider" 
      class="threshold-slider"
      min="0.75" 
      max="0.95" 
      step="0.05" 
      value="0.8"
    >
    <span id="thresholdValue" class="threshold-value">0.8</span>
  </div>
  
  <label>
    <input type="checkbox" id="titleMergeCheckbox" checked>
    Title-based merge
  </label>
  
  <div class="cluster-actions">
    <button id="reclusterBtn" class="secondary">Recluster</button>
    <button id="clearCacheBtn" class="secondary">Clear Cache</button>
    <button id="llmSettingsBtn" class="secondary">LLM Settings</button>
    <button id="runEnhancementBtn" class="primary" disabled>Run Enhancement</button>
  </div>
</section>

<section id="enhancementProgress" style="display: none;">
  <div class="progress-bar">
    <div id="progressFill" class="progress-fill"></div>
  </div>
  <div id="progressText" style="text-align: center; font-size: 13px; color: #64748b;"></div>
</section>

<section class="toolbar">
  <span id="clusterStats" class="count"></span>
</section>

<main>
  <div id="clustersGrid" class="cluster-grid"></div>
</main>

<script>
// Inline implementation of clustering functionality for better compatibility

// Data loader functionality
class DataLoader {
  constructor() {
    this.cache = new Map();
    this.buildVersion = 'v4';
  }

  async loadNews(force = false) {
    const cacheKey = 'news-data';
    if (!force && this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    try {
      const url = `data/news.json?v=${Date.now()}`;
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: Failed to load news data`);
      }
      
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error('Invalid news data format: expected array');
      }

      this.cache.set(cacheKey, data);
      return data;
    } catch (error) {
      console.error('Failed to load news data:', error);
      throw error;
    }
  }

  getDisplayField(item, field, lang = 'zh') {
    if (!item) return '';
    
    if (lang === 'zh') {
      if (item.zh && item.zh[field] != null) return item.zh[field];
      const flatKey = field.charAt(0).toUpperCase() + field.slice(1) + 'Zh';
      if (item[flatKey] != null) return item[flatKey];
    }
    
    return item[field] ?? '';
  }

  getDisplayTags(item, lang = 'zh') {
    if (!item) return [];
    
    if (lang === 'zh') {
      if (item.zh && Array.isArray(item.zh.tags)) return item.zh.tags;
      if (Array.isArray(item.tagsZh)) return item.tagsZh;
    }
    
    return item.tags || [];
  }

  findById(data, id) {
    if (!Array.isArray(data)) return null;
    return data.find(item => String(item.id) === String(id));
  }

  clearCache() {
    this.cache.clear();
  }
}

// Simple clustering engine
class SimpleClusterEngine {
  constructor() {
    this.defaultThreshold = 0.8;
  }

  async clusterNews(newsItems, options = {}) {
    const { threshold = this.defaultThreshold, enableTitleMerge = true, lang = 'zh' } = options;
    
    console.log(`Clustering ${newsItems.length} news items with threshold ${threshold}`);
    
    // Simple clustering based on tags and source
    const clusters = this.performSimpleClustering(newsItems, threshold, lang);
    
    // Title merging if enabled
    let finalClusters = clusters;
    if (enableTitleMerge) {
      finalClusters = this.mergeSimilarTitles(clusters, lang);
    }

    const result = this.generateClusterMetadata(finalClusters, lang);
    console.log(`Clustering complete: ${result.length} clusters from ${newsItems.length} items`);
    
    return result;
  }

  performSimpleClustering(newsItems, threshold, lang) {
    const clusters = [];
    const assigned = new Set();

    newsItems.forEach((item, index) => {
      if (assigned.has(index)) return;

      const cluster = [item];
      assigned.add(index);

      // Find items with similar tags or same source
      newsItems.forEach((otherItem, otherIndex) => {
        if (assigned.has(otherIndex)) return;

        const similarity = this.calculateSimilarity(item, otherItem, lang);
        if (similarity >= threshold) {
          cluster.push(otherItem);
          assigned.add(otherIndex);
        }
      });

      clusters.push(cluster);
    });

    return clusters;
  }

  calculateSimilarity(item1, item2, lang) {
    const tags1 = new Set((item1.tags || []).map(t => t.toLowerCase()));
    const tags2 = new Set((item2.tags || []).map(t => t.toLowerCase()));
    
    // Tag overlap
    const intersection = new Set([...tags1].filter(t => tags2.has(t)));
    const union = new Set([...tags1, ...tags2]);
    const tagSimilarity = union.size > 0 ? intersection.size / union.size : 0;
    
    // Source similarity
    const sourceSimilarity = item1.source === item2.source ? 0.3 : 0;
    
    return Math.min(1.0, tagSimilarity + sourceSimilarity);
  }

  mergeSimilarTitles(clusters, lang) {
    // Simple title merging - merge clusters where main items have similar titles
    const merged = [];
    const used = new Set();

    clusters.forEach((cluster, index) => {
      if (used.has(index)) return;

      let currentCluster = [...cluster];
      used.add(index);

      clusters.forEach((otherCluster, otherIndex) => {
        if (used.has(otherIndex)) return;

        const title1 = dataLoader.getDisplayField(cluster[0], 'title', lang).toLowerCase();
        const title2 = dataLoader.getDisplayField(otherCluster[0], 'title', lang).toLowerCase();
        
        // Simple title similarity check
        const commonWords = title1.split(' ').filter(word => 
          title2.includes(word) && word.length > 3
        );
        
        if (commonWords.length >= 2) {
          currentCluster.push(...otherCluster);
          used.add(otherIndex);
        }
      });

      merged.push(currentCluster);
    });

    return merged;
  }

  generateClusterMetadata(clusters, lang) {
    return clusters.map((cluster, index) => {
      // Sort items by date (newest first)
      cluster.sort((a, b) => new Date(b.date) - new Date(a.date));

      const topic = this.generateClusterTopic(cluster, lang);
      const sources = [...new Set(cluster.map(item => item.source))];
      
      return {
        id: `cluster-${index}`,
        topic,
        items: cluster,
        count: cluster.length,
        sources: sources.sort(),
        enhanced: false,
        enhancedTopic: null,
        enhancedSummary: null
      };
    }).sort((a, b) => b.count - a.count);
  }

  generateClusterTopic(items, lang) {
    if (items.length === 1) {
      return dataLoader.getDisplayField(items[0], 'title', lang) || 'Untitled';
    }

    const sources = new Set(items.map(item => item.source));
    const allTags = items.flatMap(item => item.tags || []);
    const tagCounts = {};
    
    allTags.forEach(tag => {
      tagCounts[tag] = (tagCounts[tag] || 0) + 1;
    });

    const topTags = Object.entries(tagCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 2)
      .map(([tag]) => tag);

    if (sources.size === 1) {
      return `${Array.from(sources)[0]} - ${topTags.join(', ')}`;
    } else {
      return topTags.join(' & ') || 'Mixed Topics';
    }
  }

  getClusteringStats(clusters) {
    const totalItems = clusters.reduce((sum, cluster) => sum + cluster.count, 0);
    const avgClusterSize = totalItems / clusters.length;
    const singletons = clusters.filter(c => c.count === 1).length;
    
    return {
      totalClusters: clusters.length,
      totalItems,
      avgClusterSize: Math.round(avgClusterSize * 100) / 100,
      singletons,
      largestCluster: Math.max(...clusters.map(c => c.count)),
      sources: [...new Set(clusters.flatMap(c => c.sources))].length
    };
  }
}

// Simple card renderer
class SimpleCardRenderer {
  renderClustersGrid(clusters, containerId, lang = 'zh') {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`Container ${containerId} not found`);
      return;
    }

    container.innerHTML = '';
    
    if (clusters.length === 0) {
      container.innerHTML = `
        <div class="empty-state">
          <p>No clusters found. Try adjusting the threshold or clearing the cache.</p>
        </div>
      `;
      return;
    }

    clusters.forEach(cluster => {
      const card = this.renderClusterCard(cluster, lang);
      container.appendChild(card);
    });
  }

  renderClusterCard(cluster, lang = 'zh') {
    const card = document.createElement('div');
    card.className = 'cluster-card';
    card.dataset.clusterId = cluster.id;

    const enhancedBadge = cluster.enhanced ? 
      '<span class="llm-badge" title="Enhanced by LLM">✨ AI</span>' : '';

    const displayItems = cluster.items.slice(0, 3);
    const hasMore = cluster.items.length > 3;

    card.innerHTML = `
      <div class="cluster-header">
        <h3 class="cluster-title">
          ${this.escapeHtml(cluster.enhancedTopic || cluster.topic)}
          ${enhancedBadge}
        </h3>
        <div class="cluster-stats">
          <span class="item-count">${cluster.count} items</span>
          <span class="source-list">${cluster.sources.slice(0, 2).join(', ')}${cluster.sources.length > 2 ? ' +' + (cluster.sources.length - 2) : ''}</span>
        </div>
      </div>
      
      ${cluster.enhancedSummary ? `
        <div class="cluster-summary">
          ${this.escapeHtml(cluster.enhancedSummary)}
        </div>
      ` : ''}
      
      <div class="cluster-items">
        ${displayItems.map(item => this.renderNewsItem(item, lang)).join('')}
        ${hasMore ? `
          <div class="expand-toggle">
            <button class="expand-btn" onclick="this.closest('.cluster-card').classList.toggle('expanded')">
              <span class="expand-text">Show ${cluster.items.length - 3} more items</span>
              <span class="collapse-text">Show less</span>
            </button>
          </div>
        ` : ''}
      </div>
      
      ${hasMore ? `
        <div class="cluster-items-hidden">
          ${cluster.items.slice(3).map(item => this.renderNewsItem(item, lang)).join('')}
        </div>
      ` : ''}
    `;

    return card;
  }

  renderNewsItem(item, lang = 'zh') {
    const title = dataLoader.getDisplayField(item, 'title', lang);
    const summary = dataLoader.getDisplayField(item, 'summary', lang);
    const tags = dataLoader.getDisplayTags(item, lang);

    return `
      <div class="news-item" data-id="${item.id}">
        <h4 class="item-title">${this.escapeHtml(title)}</h4>
        <div class="item-meta">${this.escapeHtml(item.source)} · ${this.formatDate(item.date)}</div>
        <div class="item-summary">${this.truncateText(this.escapeHtml(summary), 150)}</div>
        <div class="item-tags">
          ${tags.slice(0, 3).map(tag => `<span class="tag">${this.escapeHtml(tag)}</span>`).join('')}
        </div>
        <div class="item-actions">
          <a href="${item.url || '#'}" target="_blank" rel="noopener" class="source-link">Source</a>
          <button class="card-btn" onclick="window.location.href='card-generator.html?id=${item.id}'">Card</button>
        </div>
      </div>
    `;
  }

  escapeHtml(str = '') {
    return str.replace(/[&<>"']/g, c => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[c]));
  }

  formatDate(dateStr) {
    try {
      const date = new Date(dateStr);
      return `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
    } catch {
      return dateStr;
    }
  }

  truncateText(text, maxLength) {
    if (!text || text.length <= maxLength) return text;
    return text.slice(0, maxLength) + '…';
  }
}

// Initialize global instances
const dataLoader = new DataLoader();
const clusterEngine = new SimpleClusterEngine();
const cardRenderer = new SimpleCardRenderer();

// Global state
const state = {
  newsData: [],
  clusters: [],
  isProcessing: false,
  lang: 'zh'
};

// Initialize app
document.addEventListener('DOMContentLoaded', async () => {
  initializeEventListeners();
  await loadAndCluster();
  
  // Load language preference
  state.lang = localStorage.getItem('mv.lang') || 'zh';
});

function initializeEventListeners() {
  // Threshold slider
  const slider = document.getElementById('thresholdSlider');
  const valueDisplay = document.getElementById('thresholdValue');
  
  slider.addEventListener('input', (e) => {
    valueDisplay.textContent = e.target.value;
  });
  
  // Recluster button
  document.getElementById('reclusterBtn').addEventListener('click', async () => {
    await recluster();
  });
  
  // Clear cache button
  document.getElementById('clearCacheBtn').addEventListener('click', () => {
    dataLoader.clearCache();
    showStatus('Cache cleared', 'success');
    recluster();
  });
  
  // LLM settings button
  document.getElementById('llmSettingsBtn').addEventListener('click', () => {
    showStatus('LLM settings panel not implemented in simple version', 'info');
  });
  
  // Run enhancement button
  document.getElementById('runEnhancementBtn').addEventListener('click', async () => {
    showStatus('LLM enhancement not available in simple version', 'info');
  });
  
  // Language toggle
  document.getElementById('langToggleBtn').addEventListener('click', () => {
    state.lang = state.lang === 'zh' ? 'en' : 'zh';
    localStorage.setItem('mv.lang', state.lang);
    renderClusters();
  });
}

async function loadAndCluster() {
  if (state.isProcessing) return;
  
  state.isProcessing = true;
  updateStatus('Loading data...');
  
  try {
    // Load news data
    state.newsData = await dataLoader.loadNews();
    
    // Perform initial clustering
    await recluster(false);
    
  } catch (error) {
    console.error('Failed to load and cluster:', error);
    showStatus(`Error: ${error.message}`, 'error');
  } finally {
    state.isProcessing = false;
  }
}

async function recluster(showMessage = true) {
  if (state.isProcessing) return;
  
  state.isProcessing = true;
  if (showMessage) updateStatus('Reclustering...');
  
  try {
    const threshold = parseFloat(document.getElementById('thresholdSlider').value);
    const enableTitleMerge = document.getElementById('titleMergeCheckbox').checked;
    
    state.clusters = await clusterEngine.clusterNews(state.newsData, {
      threshold,
      enableTitleMerge,
      lang: state.lang
    });
    
    renderClusters();
    updateClusterStats();
    
    if (showMessage) showStatus('Clustering complete', 'success');
    
  } catch (error) {
    console.error('Clustering failed:', error);
    showStatus(`Clustering error: ${error.message}`, 'error');
  } finally {
    state.isProcessing = false;
  }
}

function renderClusters() {
  cardRenderer.renderClustersGrid(state.clusters, 'clustersGrid', state.lang);
}

function updateClusterStats() {
  const statsEl = document.getElementById('clusterStats');
  if (!statsEl) return;
  
  const stats = clusterEngine.getClusteringStats(state.clusters);
  
  statsEl.innerHTML = `
    ${stats.totalClusters} clusters from ${stats.totalItems} news items
    (${stats.singletons} single items, avg size: ${stats.avgClusterSize})
  `;
}

function updateStatus(message) {
  const statsEl = document.getElementById('clusterStats');
  if (statsEl) {
    statsEl.textContent = message;
  }
}

function showStatus(message, type = 'info') {
  // Create temporary status message
  const status = document.createElement('div');
  status.className = `status-message ${type}`;
  status.textContent = message;
  status.style.position = 'fixed';
  status.style.top = '20px';
  status.style.right = '20px';
  status.style.zIndex = '1001';
  status.style.maxWidth = '300px';
  status.style.padding = '8px 12px';
  status.style.borderRadius = '6px';
  status.style.fontSize = '13px';
  
  if (type === 'success') {
    status.style.background = '#dcfce7';
    status.style.color = '#16a34a';
    status.style.border = '1px solid #bbf7d0';
  } else if (type === 'error') {
    status.style.background = '#fef2f2';
    status.style.color = '#dc2626';
    status.style.border = '1px solid #fecaca';
  } else {
    status.style.background = '#eff6ff';
    status.style.color = '#2563eb';
    status.style.border = '1px solid #dbeafe';
  }
  
  document.body.appendChild(status);
  
  setTimeout(() => {
    status.remove();
  }, 3000);
}

// Export for global access
window.clusterApp = {
  state,
  recluster,
  showStatus
};
</script>

<script src="news-utils.js?v=v4"></script>
</body>
</html>
